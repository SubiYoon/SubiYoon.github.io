---
tags:
  - HTTP완벽가이드
---

# 다이제스트 인증
- 다이제스트 인증은 기본인증과 호환되는 더 안전한 대체재로서 개발되었다.
- 널리 쓰이지는 않지만, 해당 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다.
    - 현재는 잘 사용되어지고 있지는 않다.

### 다이제스트 인증의 특징

- 기본인증과 달리 해당 정보를 평문으로 보내지 않는다.
- 인증 체결을 가로채서 재현하려는 행위를 차단한다.
- 구현하기에 따라 메시지 내용의 위조를 막는 것도 가능하다.
- 몇몇 알려진 공격들에 대해 방어한다.

### 비밀번호를 안전하게 지키기위해 요약 사용하기

- 다이제스트 인증은 비밀번호를 절대 네트워크를 통해 보내지 않는다.
- 서버와 클라이언트 모두 비밀번호를 가지고 있고, 해당 비밀번호의 요약문을 전송한다.
    - 이 때, 세상에 모든 비밀번호를 시도해보지 않는이상 원래 비밀번호를 알기 힘들다.
- **동작원리**
    - 클라이언트는 서버에 해당 데이터에 대한 요청을 보낸다.
    - 서버는 인증이 완료되기까지 문서 제공을 거부하고 클라이언트에 인증을 요구한다.
    - 클라이언트는 이름과 비밀번호를 입력하고 이를 요약 후 서버에게 보낸다.
    - 모든 사용자를 알고있는 서버는 받아온 요약과 서버가 가지고 있는 요약로직을 사용해 비교한다.
    - 인증이 완료되면 해당 문서를 클라이언트에게 보내준다.
 
### 단방향 요약

- 요약함수는 보통 **암호 체크섬(crptographic checksums)**으로 불린다.
	- 단방향 해시 함수
	- 지문 함수(fingerprint function)
- 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.

### 재전송 방지를 위한 난스(nonce) 사용
- 단방향 요약은 비밀번호를 사용하지 않지만, 요약 자체가 비밀번호라고 해도 무방하다. 때문에 비밀번호를 모른다고 하더라도 요약을 가로채 서버로 몇번이고 전송 할 수 있다. 이러한 재전송 공격을 방지하기 위해 서버는 **난스(nonce)**라고하는 자주 변경(대략 1ms마다 or 인증할 때마다)되는 증표를 건네준다.
- **난스(nonce)**를 비밀번호에 섞으면 난스 변경시 요약도 변경되는데 이로 인해 재전송 공격을 막아주게 된다.

### 다이제스트 인증 핸드셰이크
- 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택 적인 헤더인 **Authorization-Info**가 추가 되었다.
- **1단계**
	- 서버는 난스 값을 계산
- **2단계**
	- 서버는 난스를 **WWW-Authenticate** 인증 요구 메시지에 담아 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.
- **3단계**
	- 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다.
- **4단계**
	- 클라이언트는 **Authorization** 메시지에 요약을 담아 서버에게 보낸다.
	- 만약, 클라이언트가 서버를 인증하길 원한다면 클라이언트 **난스(nonce)**를 보낼 수 있다.
- **5단계**
	- 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터를 받고 클라이언트가 했던 방식으로 요약을 진행한다.
	- 서버는 자신이 요약한 결과와 클라이언트가 보낸 요약을 비교해 일치하는지 확인한다.
	- 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.


---
# 요약 계산
- 다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.

### 요약 알고리즘 입력 데이터
- 단방향 해시 함수 H(d)
- 요약 함수 KD(s,d)
- s는 비밀(secret)을 의미한다.
- d는 데이터(data)를 의미한다.
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩이리를 A1
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리를 A2

### H(d)와 KD(s,d) 알고리즘
* 기본값 : MD5
* RF2617에 제안된 알고리즘 : MD5, MD5-sess('sess'는 session을 뜻함)
* 그 외 여러 요약 알고리즘을 지원함

### 보안 관련 데이터(A1)
* 사용자 이름, 비밀번호, 보호영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.
	* 메시지 자체가 아닌 비밀 정보와만 관련되어 있음을 명확히 이해해야 한다.
	* A1은 H, KD, A2와 마찬가지로 요약을 개산하기 위해 사용된다.

| 알고리즘     | A1                                     |
| -------- | -------------------------------------- |
| MD5      | A1 = <사용자>:<영역>:<비밀번호>                 |
| MD5-sess | A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스> |

### 메시지 관련 데이터(A2)
* URL, 요청 메서드(GET, POST, PUT, DELETE, ...), 메시지 엔터티 본문과 같은 메시지 자체의 정보
* 메시지 위조 방지를 위해 사용
* **방법1**
	* HTTP 요청 메서드와 URL만 포함하는 것
	* `pop="auth"`일 때 사용
* **방법2**
	* 메시지 무결성 검사를 제공하기 위해 엔티티 본문을 추가하는 것
	* `pop="auth-int"`일 때 사용
* **uri 지시자 값**
	* 반드시 요청 URI와 일치해야 한다.
	* URI가 absoluteURL이라면 uri 지시자 값도 반드시 absoluteURL이어야 한다.

| qop      | A2                                  |
| -------- | ----------------------------------- |
| 정의되지 않음  | <요청 메서드>:<uri 지시자 값>                |
| auth     | <요청 메서드>:<uri 지시자 값>                |
| auth-int | <요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>) |

### 요약 알고리즘 전반
* **방법1**
	* qop옵션이 빠졌을 경우 사용
	* 비밀 정보와 난스가 붙은 메시지 데이터를 해시를 이용해 요약 계산한다.
* **방법2**
	* qop옵션이 `"auth"`와 `"auth-int"`일 때 모두 사용
	* 난스 횟수, qop, c난스 데이터를 요약에 추가한다.

| qop              | 요약 알고리즘                                  | 비고                 |
| ---------------- | ---------------------------------------- | ------------------ |
| 정의되지 않음          | KD(H(H1), <난스>:H(A2))                    | 없어질 예정(Deprecated) |
| auth or auth-int | KD(H(H1), <난스>:\<nc>:<c난스>:\<qop>:H(A2)) | 이 방법을 선호           |

예시)

| qop      | 알고리즘                         | 펼쳐진 알고리즘                                     |
| -------- | ---------------------------- | -------------------------------------------- |
| 정의되지 않음  | <정의되지 않음><br>MD5<br>MD5-sess | MD5(MD5(A1):<난스>:MD5(A2))                    |
| auth     | <정의되지 않음><br>MD5<br>MD5-sess | MD5(MD5(A1):<난스>:\<nc>:<c난스>:\<qop>:MD5(A2)) |
| auth-int | <정의되지 않음><br>MD5<br>MD5-sess | MD5(MD5(A1):<난스>:\<nc>:<c난스>:\<qop>:MD5(A2)) |

### 다이제스트 인증 세션
* WWW-Authenticate 에 대한 클라이언트 응답은 그 보호 공간에 대한 인증 세션을 시작한다.
* 인증 세션은 다른 서버로 부터 또 다른 WWW-Authenticate 인증 요구를 받을 때 까지 지속한다.
* 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 채택할 수 있다. 아니면, 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다.
	* `"stale=true"`로 정의하여 서버는 클라이언트에게 새 난스 값으로 요청을 다시 요청

### 사전(preemptive)인가
* 모든 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로하는데, 클라이언트가 다음 난스가 무엇이 될지 미리 파악하여 요청/인증요구 사이클을 생략하는 방법
* **방법**
	* 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아 미리 보내기
		* `Authentication-Info: nextnonce="<난스 값>"`
	* 서버가 짧은 시간동안 같은 난스를 재사용하는 것을 허용
		* 난스가 만료되면 서버는 `401 Unauthorized`인증 요구를 보냄
		* `WWW-Authenticate`는 다음과 같이 설정된다.
		* `WWW-Authenticate: Digeset realm="<영역 값>" nonce="<난스 값>" stale=true`
		* 해당 기능을 사용하면 재전송 공격이 성공하기 쉬워진다는 점을 고려해야 한다.
	* 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용
		* ex) 제 3자가 예측할 수 없는 공유된 비밀키에 기반하여 서버와 클라이언트가 동시에 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용