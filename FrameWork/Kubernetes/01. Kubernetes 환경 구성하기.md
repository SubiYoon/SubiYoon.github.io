---
tags:
  - FrameWork
  - Kuberntes
---
# 사전 준비
* Virtual Machine Program
* Ubuntu 22.04.x server(.iso)

# Ubuntu 기본 설정
### Ubuntu 설치 후 설치해야 하는 것들
Ubuntu 22.04.x LTS를 설치하면 minimized로 설치하지 않는이상 Ubuntu에서 자동으로 설치해주는 툴들이 있다. 하지만, 설치가 되지 않는 것들도 존재하는데 이것들을 설치해주자.
1) vim
	* 어떠한 에디터를 사용하던 상관은 없지만, 이미 vim에 노예이기에 vim을 설치하자.
	* Ubuntu 22.04에서 기본적으로 vim-tiny가 설치되어 있다. 우리는 vim이랑 똑같이 동작하지만, 하이라이트 적용을 위해 새로운 vim을 설치하자.
```bash
sudo apt update

# vim-tiny 삭제
sudo apt remove vim-tiny

#vim 설치
sudo apt install vim
```
2) net-tools
	* 기본적으로 설치된 환경에서는 `ifconfig`조차 사용 할 수 없기에 설치해주자.
```bash
sudo apt install net-tools
```
3) openvswitch-switch
	* `netplan apply`를 사용하면 에러가 발생하는데 이를 해결하기 위해 설치하자.
```bash
sudo apt install openvswitch-switch
```

### 기타 설치하면 유용한 것들
꼭 설치할 필요는 없지만, 사용하면 용이한 것들이다. 참고하자.
1) neofetch
	* 시스템 정보를 나타내주는 녀석... 이쁘다...
```bash
sudo apt install neofetch
```
![image](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc54e308-b555-4004-9ba3-ac0d3c344f76/4fc03d5a-d189-4a71-88b9-1b4f77c428e8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240416%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240416T091154Z&X-Amz-Expires=3600&X-Amz-Signature=408a2d39f9f7dda4ddb7b8603320fb698052892a28e79ce3015faad668b33df3&X-Amz-SignedHeaders=host&x-id=GetObject)

2) bpytop
	* 답답한 htop의 UI를 이쁘게 표현해주는 녀석이다.
```bash
sudo apt install bpytop
```

![image](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc54e308-b555-4004-9ba3-ac0d3c344f76/9eaa11d2-a347-4084-abc1-d001e19cad01/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240416%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240416T091154Z&X-Amz-Expires=3600&X-Amz-Signature=cba0bbe7112e75c4a443f4878daa2915edd06e240f5311afd96eb69775feb10e&X-Amz-SignedHeaders=host&x-id=GetObject)

---
# 네트워크 환경 구성
### 고정 IP 설정
IP를 고정하려면 게이트웨이의 IP를 미리 확인해 두어야한다.
```bash
# sudo route -n

0.0.0.0 ${gateway ip} ...
```


```yaml
# sudo vi /etc/netplan/00-installer-config.yaml

# 해당하는 이더넷 설정을 변경하면 된다.
network:
  ethernets:
    # ifconfig로 이더넷포트 이름을 확인 후 알맞은 곳을 수정해야한다.
    enp0: false
    addresses:
      - ${gateway ip 앞 세자리}.104/24  # hosts에서 설정한 master의 ip
    routes:
      - to: default
        via: ${gateway ip}
    nameservers:
      addresses: [${gateway ip 앞 세자리}.101, 8.8.8.8, 8.8.4.4]
  version: 2
```

이제 고정 ip가 정상적으로 작동을 하는지 적용 후 테스트를 해보아야 한다.
아래 문구를 입력 후 정상 적동한다면 netplan 설정엔 오류가 없다는 것이다.
```bash
sudo netplan apply
```

테스트를 해보자.
가만히 두면 계속 올라오니  `control + c`로 중간에 멈춰야 한다.
아래와 같이 나온다면 정상적으로 네트워크가 동작한다는 것을 의미한다.
```bash
# ping 8.8.8.8

PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=45.9 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=111 time=46.4 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=111 time=54.7 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=111 time=47.3 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=111 time=48.4 ms
64 bytes from 8.8.8.8: icmp_seq=6 ttl=111 time=46.6 ms
64 bytes from 8.8.8.8: icmp_seq=7 ttl=111 time=47.8 ms
64 bytes from 8.8.8.8: icmp_seq=8 ttl=111 time=47.5 ms
64 bytes from 8.8.8.8: icmp_seq=9 ttl=111 time=47.4 ms
^C
--- 8.8.8.8 ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 8019ms
rtt min/avg/max/mdev = 45.949/48.016/54.694/2.465 ms
```

### hostname 설정
각각의 서버에 Domain을 대신할 hostname을 설정하자.
```bash
# sudo vi /etc/hostname

# 맨 첫줄에 내용이 있다면 삭제하고 다음을 입력 후 저장하고 빠져나오자.
master.example.com
```

### hosts 설정
```bash
#sudo vi/etc/hosts

127.0.0.1 localhost
127.0.0.1 ${server-name}

#위의 내용을 다음과 같이 변경하자
128.0.0.1 localhost
 ${gateway ip 앞 세자리}.104 master.example.com master
 ${gateway ip 앞 세자리}.101 node1.example.com node1
 ${gateway ip 앞 세자리}.102 node2.example.com ndoe2
```

### 재시작
재시작을 통해 해당 설정이 정상적으로 되었는지 확인해보자.
```bash
sudo reboot
```

로그인 화면에서 일부러 비밀번호를 틀리면 hostname이 적힌 화면이 나오게 된다.
아래와 같이 나온다면 성공!!
```bash
master login : 
Password:

Login incorrect
master.example.com login : 
```

아래 커맨드를 입력후 결과값이 같다면 정상 동작한다는 것을 의미한다.
```bash
# hosthame
master.example.com
```

---
# docker 설치
도커의 경우 설치 방법이 생각보다 자주 변경된다.
때문에... 도커 홈페이지를 통해 설치하도록하자...
절대!! 귀찮아서가 아니다...

---
# 복제품 만들기
복제품을 만드는 이유는 Kubernetes를 사용하려면 여러개의 서버가 필요하기 때문이다.
우리는 앞에서 한 작업을 하나하나 다시 만들어주는 과정이 너무 귀찮아!!!!
복제품을 만들어서 몇가지만 수정하자.

---
# Kuberntes 설치
우선... 가장 좋은 방법은 홈페이지를 통해 설치하는 방법이다.
이유는 도커와 같지만, 일단 이녀석의 설치를 위한것이니 설명으 시작한다.

### Swap Momoty Off하기
우선 가장 먼저 해야하는 것이 Swap Memory를 꺼야하는 것이다.
왜 꺼야하는지는 아래 제목의 게시글에서 확인하자.

>[[00. Kubernetes 구성중 Swap Memory를 끄는 이유!!]]

```bash
sudo swapoff -a && sed -i '/swap/s/^/#/' /etc/fstab

# 만약 Permission denied가 발생한다면 root계정으로 접속해서 실행하자.
sudo su
```

### 필요한 모듈 로드
```bash
## 모듈 로드
sudo modprobe br_netfilter

## 커널 모듈을 지정
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF

## 커널에서 브리지에 묶여있는 Traffic들이 iptable을 바라보도록 설정
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

## 설정 확인
sudo sysctl --system
```

>br_netfilter : k8s가 네트워크 트래픽을 제어하는 기능 제공  
/etc/modules-load.d/k8s.conf : 시스템 부팅 시 로드할 커널 모듈을 지정  
/etc/sysctl.d/: 적용할 커널 파라미터를 정의하는 설정 파일들을 저장하는 곳
### Kubernetes apt Repository를 사용하기 위한 사전 작업
```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
```

### 구글 클라우의 공개 사이닝 키를 다운로드
```bash
sudo curl -fsSLo /etc/apt/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
```

### Kubernetes apt Repository를 추가
```bash
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
```

### Kubeadm, Kubelet, Kubectl 설치
- `kubeadm`: 클러스터를 부트스트랩하는 명령이다.
- `kubelet`: 클러스터의 모든 머신에서 실행되는 파드와 컨테이너 시작과 같은 작업을 수행하는 컴포넌트이다.
- `kubectl`: 클러스터와 통신하기 위한 커맨드 라인 유틸리티이다.
```bash
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

docker를 사용한다면 발생할 문제점이다..
자세한 내용은 공식홈페이지를 통해 확인하기 바란다.
간략히 설명하자면 Kubernetes에서 1.24버전 이후에서는 docker를 내다 버렸다는 것이다.
완전 내다 버린것은 아니고... docker에서 사용하는 containerd를 기반으로 동작하는 방향으로 틀었다는 것!! 이유는.. 직접 찾아보자...ㅎㅎ
```shell
master: deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main
master: Hit:1 https://download.docker.com/linux/ubuntu jammy InRelease
master: Hit:3 http://ports.ubuntu.com/ubuntu-ports jammy InRelease
master: Ign:2 https://packages.cloud.google.com/apt kubernetes-xenial InRelease
master: Hit:4 http://ports.ubuntu.com/ubuntu-ports jammy-updates InRelease 
master: Err:5 https://packages.cloud.google.com/apt kubernetes-xenial Release 
master: 404 Not Found [IP: 142.250.76.142 443]
master: Hit:6 http://ports.ubuntu.com/ubuntu-ports jammy-backports InRelease 
master: Get:7 http://ports.ubuntu.com/ubuntu-ports jammy-security InRelease [110 kB]
master: Reading package lists...
master: E: The repository 'https://apt.kubernetes.io kubernetes-xenial Release' does not have a Release file.
master:
master: WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
master:
master: Reading package lists...
master: Building dependency tree...
master: Reading state information...
master: E: Unable to locate package kubelet
master: E: Unable to locate package kubectl
master: E: Unable to locate package kubeadm
```

아래 명령어를 통해 해당 문제를 해결해보도록 하자.
그 다음은?? 다시 위로 올라가서 설치 명령어를 실행하자.
```bash
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.23/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.23/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update
```
```bash
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.24/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.24/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update
```

> 설치 명령이 동작하지 않으면 아래 블로그를 참고.
> https://littlemobs.com/blog/kubernetes-package-repository-deprecation/

---
# Kubernetes 환경 구성
### Kubernetes init
설치가 완료 되었다면 다음과 같이 master에서 kubernetes를 초기화 주어야 한다.
주의해야할 점은 반드시!!! master에서 해주어야 한다는 것이다.
```bash
sudo kubeadm init
```

위의 명령어를 실행 후 한가지 에러가 발생 했다.
```bash
I0422 01:11:18.005401    3360 version.go:256] remote version is much newer: v1.30.0; falling back to: stable-1.24
[init] Using Kubernetes version: v1.24.17
[preflight] Running pre-flight checks
error execution phase preflight: [preflight] Some fatal errors occurred:
        [ERROR CRI]: container runtime is not running: output: time="2024-04-22T01:11:18Z" level=fatal msg="validate service connection: CRI v1 runtime API is not implemented for endpoint \"unix:///var/run/containerd/containerd.sock\": rpc error: code = Unimplemented desc = unknown service runtime.v1.RuntimeService"
, error: exit status 1
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`
To see the stack trace of this error execute with --v=5 or higher
```

위의 문제는 containered의 문제 인데 해당 파일의 환경설정 파일을 열어 아래 부분에 주석을 해주어야 init이 정상적으로 작동하는 것을 알 수 있다.
master와 node들 전부 다음 설정을 해주어야 한다.
```bash
sudo vi /etc/containerd/config.toml
```
```toml title:"/etc/containerd/config.toml"
#   Copyright 2018-2022 Docker Inc.

#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at

#       http://www.apache.org/licenses/LICENSE-2.0

#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

- disabled_plugins = ["cri"]
+ # disabled_plugins = ["cri"]

#root = "/var/lib/containerd"
#state = "/run/containerd"
#subreaper = true
#oom_score = 0

#[grpc]
#  address = "/run/containerd/containerd.sock"
#  uid = 0
#  gid = 0

#[debug]
#  address = "/run/containerd/debug.sock"
#  uid = 0
#  gid = 0
#  level = "info"
```

다시 Kubernetes를 초기화해주자.
```bash
sudo systemctl restart containerd
sudo kubeadm init
```

위의 명령어가 실행되면 `control-pan(master)`시스템에 `API controller scheduler etcd coredns`가 구성된다.
인증을 위해 Kubernetes 관리자의 계의 홈디렉토리에 인증 정보를 저장하자.
또한 생성된 토큰을 차후 워커 노드들의 연결위해 저장해 두자.

```bash
To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.0.47:6443 --token wlsrwu.mann8cd5v52tf9sr \
        --discovery-token-ca-cert-hash sha256:63122f8a213d74c8ea21c03bb7272c985675ba14cbda943c32ee7d9358f44bab
```

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# 위에 3개를 실행 후 다음 명령어를 실행시켜주자.
export KUBECONFIG=/etc/kubernetes/admin.conf
```

```bash
cat > token.txt
kubeadm join 192.168.0.47:6443 --token wlsrwu.mann8cd5v52tf9sr \
        --discovery-token-ca-cert-hash sha256:63122f8a213d74c8ea21c03bb7272c985675ba14cbda943c32ee7d9358f44bab
```

### Installing a Pod Network Add-on
다음 주소에 들어가서 addon을 해주자.
링크가 자주 변경되니 Kubernetes홈페이지에서 addon 사이트를 확인 후 접속하자.
* `https://kubernetes.io/docs/concepts/cluster-administration/addons/#networking-and-network-policy`

만약 해당 IP:port에서 거부당했고 호스트와 포트가 옳바른지를 물어본다면 아래의 명령어를 사용하여 해결해보도록 하자.
```bash
sudo -i
swapoff -a
exit
strace -eopenat kubectl version
```

아래와 같이 목록이 나온다면 `weave net` addon이 완료된 것이다.
```bash
# kubectl get --all-namespaces

NAMESPACE     NAME                                         READY   STATUS      RESTARTS         AGE
kube-system   coredns-57575c5f89-2d6lw                     0/1     Completed   21               134m
kube-system   coredns-57575c5f89-g862z                     0/1     Completed   16               134m
kube-system   etcd-master.example.com                      1/1     Running     41 (2m37s ago)   135m
kube-system   kube-apiserver-master.example.com            0/1     Running     45 (34s ago)     135m
kube-system   kube-controller-manager-master.example.com   1/1     Running     43 (6m20s ago)   135m
kube-system   kube-proxy-wzddq                             0/1     Error       25               134m
kube-system   kube-scheduler-master.example.com            1/1     Running     42 (5m18s ago)   133m
kube-system   weave-net-wgb5l                              2/2     Running     52 (38s ago)     133m
```

```bash
# kubectl get nodes
NAME                 STATUS   ROLES           AGE    VERSION
master.example.com   Ready    control-plane   146m   v1.24.17
```

