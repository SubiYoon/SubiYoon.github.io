---
tags:
  - FrameWork
  - Kuberntes
---
# 사전 준비
* Virtual Machine Program
* Ubuntu 24.04.x server(.iso)

# Ubuntu 기본 설정
### Ubuntu 설치 후 설치해야 하는 것들
Ubuntu 22.04.x LTS를 설치하면 minimized로 설치하지 않는이상 Ubuntu에서 자동으로 설치해주는 툴들이 있다. 하지만, 설치가 되지 않는 것들도 존재하는데 이것들을 설치해주자.
1) vim
	* 어떠한 에디터를 사용하던 상관은 없지만, 이미 vim에 노예이기에 vim을 설치하자.
	* Ubuntu 22.04에서 기본적으로 vim-tiny가 설치되어 있다. 우리는 vim이랑 똑같이 동작하지만, 하이라이트 적용을 위해 새로운 vim을 설치하자.
```bash
sudo apt update

# vim-tiny 삭제
sudo apt remove vim-tiny

#vim 설치
sudo apt install vim
```
2) net-tools
	* 기본적으로 설치된 환경에서는 `ifconfig`조차 사용 할 수 없기에 설치해주자.
```bash
sudo apt install net-tools
```
3) openvswitch-switch
	* `netplan apply`를 사용하면 에러가 발생하는데 이를 해결하기 위해 설치하자.
```bash
sudo apt install openvswitch-switch
```
4) arping
	* 지금 사용하려는 ip가 충돌이 발생하는지를 확인 할 수 있다.
```bash
sudo apt install arping

# 사용방법
arping -q -D -I "인터페이스 이름" -c 1 "체크할 IP"; echo $?
```

### 기타 설치하면 유용한 것들
꼭 설치할 필요는 없지만, 사용하면 용이한 것들이다. 참고하자.
1) neofetch
	* 시스템 정보를 나타내주는 녀석... 이쁘다...
```bash
sudo apt install neofetch
```
![image](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc54e308-b555-4004-9ba3-ac0d3c344f76/4fc03d5a-d189-4a71-88b9-1b4f77c428e8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240416%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240416T091154Z&X-Amz-Expires=3600&X-Amz-Signature=408a2d39f9f7dda4ddb7b8603320fb698052892a28e79ce3015faad668b33df3&X-Amz-SignedHeaders=host&x-id=GetObject)

2) bpytop
	* 답답한 htop의 UI를 이쁘게 표현해주는 녀석이다.
```bash
sudo apt install bpytop
```

![image](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc54e308-b555-4004-9ba3-ac0d3c344f76/9eaa11d2-a347-4084-abc1-d001e19cad01/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240416%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240416T091154Z&X-Amz-Expires=3600&X-Amz-Signature=cba0bbe7112e75c4a443f4878daa2915edd06e240f5311afd96eb69775feb10e&X-Amz-SignedHeaders=host&x-id=GetObject)

---
# 네트워크 환경 구성
### 고정 IP 설정
IP를 고정하려면 게이트웨이의 IP를 미리 확인해 두어야한다.
```bash
# sudo route -n

0.0.0.0 ${gateway ip} ...
```


```yaml title:"/etc/netplan/00-installer-config.yaml"
# sudo vi /etc/netplan/00-installer-config.yaml

# 해당하는 이더넷 설정을 변경하면 된다.
network:
  ethernets:
    # ifconfig로 이더넷포트 이름을 확인 후 알맞은 곳을 수정해야한다.
    enp0: false
    addresses:
      - ${gateway ip 앞 세자리}.110/24  # hosts에서 설정한 master의 ip
    routes:
      - to: default
        via: ${gateway ip}
    nameservers:
      addresses: [${gateway ip}]
  version: 2
```

이제 고정 ip가 정상적으로 작동을 하는지 적용 후 테스트를 해보아야 한다.
아래 문구를 입력 후 정상 적동한다면 netplan 설정엔 오류가 없다는 것이다.
```bash
sudo netplan apply
```

테스트를 해보자.
가만히 두면 계속 올라오니  `control + c`로 중간에 멈춰야 한다.
아래와 같이 나온다면 정상적으로 네트워크가 동작한다는 것을 의미한다.
```bash
# ping 8.8.8.8

PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=45.9 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=111 time=46.4 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=111 time=54.7 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=111 time=47.3 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=111 time=48.4 ms
64 bytes from 8.8.8.8: icmp_seq=6 ttl=111 time=46.6 ms
64 bytes from 8.8.8.8: icmp_seq=7 ttl=111 time=47.8 ms
64 bytes from 8.8.8.8: icmp_seq=8 ttl=111 time=47.5 ms
64 bytes from 8.8.8.8: icmp_seq=9 ttl=111 time=47.4 ms
^C
--- 8.8.8.8 ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 8019ms
rtt min/avg/max/mdev = 45.949/48.016/54.694/2.465 ms
```

### hostname 설정
각각의 서버에 Domain을 대신할 hostname을 설정하자.
```bash
# sudo vi /etc/hostname

# 맨 첫줄에 내용이 있다면 삭제하고 다음을 입력 후 저장하고 빠져나오자.
k8s-master.example.com
```

### hosts 설정
```bash
#sudo vi/etc/hosts

127.0.0.1 localhost
127.0.0.1 ${server-name}

#위의 내용을 다음과 같이 변경하자
128.0.0.1 localhost
 ${gateway ip 앞 세자리}.47 k8s-master.example.com k8s-master
 ${gateway ip 앞 세자리}.48 k8s-worker1.example.com k8s-worker1
 ${gateway ip 앞 세자리}.49 k8s-worker2.example.com k8s-worker2
```

### 재시작
재시작을 통해 해당 설정이 정상적으로 되었는지 확인해보자.
```bash
sudo reboot
```

로그인 화면에서 일부러 비밀번호를 틀리면 hostname이 적힌 화면이 나오게 된다.
아래와 같이 나온다면 성공!!
```bash
master login : 
Password:

Login incorrect
master.example.com login : 
```

아래 커맨드를 입력후 결과값이 같다면 정상 동작한다는 것을 의미한다.
```bash
# hosthame
master.example.com
```

---
# Containerd 설치
```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt-get update 
sudo apt-get install -y containerd.io

# 만약 containerd.io로 설치했는데 6443port 커넥션 관련 에러시 containerd를 설치
sudo apt-get install -y containerd
```

### plugin 주석하기
아래 부분을 주석처리해주자
주석을 처리하는 이유는 기본적으로 containerd가 CRI를 사용하지 않게 설정하기 때문이다.
```bash title:"/etc/containerd/config.toml"
# sudo vi /ect/containerd/config.toml
disabled_plugins = ["CRI"]
systemd_croup = true
```

### 적용
위 설정을 적용시켜주기 위해 아래 명령어를 입력해주자.
```bash
sudo systemctl restart containerd.service
```
---
# Kuberntes 설치
우선... 가장 좋은 방법은 홈페이지를 통해 설치하는 방법이다.
### Swap Momoty Off하기
우선 가장 먼저 해야하는 것이 Swap Memory를 꺼야하는 것이다.
왜 꺼야하는지는 아래 제목의 게시글에서 확인하자.

>[[00. Kubernetes 구성중 Swap Memory를 끄는 이유!!]]
```bash
sudo swapoff -a && sudo sed -i '/swap/s/^/#/' /etc/fstab

# 만약 Permission denied가 발생한다면 root계정으로 접속해서 실행하자.
sudo su
```

### 필요한 모듈 로드
```bash
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

## 설정 확인
sudo sysctl --system
```

>br_netfilter : k8s가 네트워크 트래픽을 제어하는 기능 제공  
/etc/modules-load.d/k8s.conf : 시스템 부팅 시 로드할 커널 모듈을 지정  
/etc/sysctl.d/: 적용할 커널 파라미터를 정의하는 설정 파일들을 저장하는 곳
### Kubernetes apt Repository를 사용하기 위한 사전 작업
```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl gpg
```

### Repository 다운로드 위한 keying
```bash
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list
```

### Kubernetes 설치
```bash
sudo apt-get update
sudo apt-get install -y kubectl kubelet kubeadm

sudo systemctl enable --now kubelet

# 자동 업데이트를 방지한다.
sudo apt-mark hold kubelet kubeadm kubectl
```

설치가 완려되었다면 master node에서 다음을 실행하자
주의해야 할 사항은 master node에만 시행해야 한다는 것이다!
```bash
sudo kubeadm init

# calico 설치시 cidr의 ip값은 사용중이라면 반드시 변경해야 한다.
sudo kubeadm init --pod-network-cidr=92.42.0.0/16 --apiserver-advertise-address 192.168.0.47
```
### Kubernetes 환경설정
```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# 만약 아래 명령 실행 후 root 계정이 아닌 일반 계정에서 오류발생시
sudo kubectl get nodes

# 만약 root계정으로 설치했다면 아래를 입력하자
export KUBECONFIG=/etc/kubernetes/admin.conf
```


환경설정을 마쳤다면 worker node에서 master node를 연결하기 위해 아래 부분은 파일에 저장해서 관리하도록 하자.
`sudo kubeadm init`이 완료되면 가장 하단부분에 아래 부분이 나올 것이다.
`vi`를 사용하던 `cat`을 사용하던 어디에 저장해두자.
```bash
cat > /home/master/token
kubeadm join 192.168.0.47:6443 --token n0vg2n.qrt10pnw174k1ibl \
        --discovery-token-ca-cert-hash sha256:a296cc52dc6458e00ca3e46beb45a008bcafda73699e784442ef406578803373
```

### CNI설치
Kubernetes홈페이지 접속하면 다양한 CNI가 존재한다.
weave를 사용해봤지만, 이유는 모르겠으나 계속 충돌이 발생해
calico를 사용해 보려고한다. 다른 CNI를 설치하고 싶다면 아래 페이지를 참고하자.
> https://kubernetes.io/docs/concepts/cluster-administration/addons/#networking-and-network-policy

calico를 설치한다.
```bash
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
```

사용자 정의 리소스 정의를 설치한다.
```bash
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/tigera-operator.yaml
```

사용자 정의 리소스를 가지고 calico를 설치한다.
```bash
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/custom-resources.yaml
```

모든 Pod이 실행중인지 확인한다.
이 때 각 Pod에 STATUS가 `Running`인지 확인될 때 까지 기다려야 한다.
```bash
watch kubectl get pods -n calico-system
```

다음 문구를 실행한다.
```bash
kubectl taint nodes --all node-role.kubernetes.io/control-plane-  
kubectl taint nodes --all node-role.kubernetes.io/master-

# 위 명령어 실행 시 아래 문구가 등장해야 한다.
node/<your-hostname> untainted
```

최종확인
```bash
kubectl get nodes -o wide

# 위 명령어 실행 시 아래 문구가 등장해야 한다.
NAME              STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION    CONTAINER-RUNTIME
<your-hostname>   Ready    master   52m   v1.12.2   10.128.0.28   <none>        Ubuntu 18.04.1 LTS   4.15.0-1023-gcp   docker://18.6.1
```

### worker node 추가하기
연결의 모든 준비가 끝나가는 시점이다.
CNI를 설치했으면 이제 일할 녀석들을 추가해주자.
각 worker node로 접속해서 아까 저장한 token파일의 내용을 실행시켜주면 된다.
```bash
kubeadm join 192.168.0.47:6443 --token n0vg2n.qrt10pnw174k1ibl \
        --discovery-token-ca-cert-hash sha256:a296cc52dc6458e00ca3e46beb45a008bcafda73699e784442ef406578803373
```

아래 명령어를 통해 잘 작동하는지 확인해보자
```bash
watch kubectl get pods -n kube-system -o wide
```

---
# Trouble Shooting
### ${ip}:6443 connection refused
6443포트에 커넥션을 맺을 수 없다고 나타났다.
이유는 아직도 정확히는 알 수 없으나, 아마 containerd.io만 설치해서는 정상작동이 되지 않는것으로 추측중이다.
만약 containerd.io만 설치해서 해당 문제가 발생한다면 containerd를 설치해서 시도해보자.
```bash
sudo apt-get install -y containerd
```

### node CrashLoopBackOff
* Kernel 의 ip_filter 에서 충돌이 발생했다면 해당 파일의 아래 문구를 추가해주자.
```bash title:"/etc/sysctl.conf"
# /etc/sysctl.conf
net.ipv4.conf.all.rp_filter = 1
```

추가했다면 다음 명령어를 통해 커널에 반영해주자.
```bash
sysctl -p
```

* "10.96.0.1:443: connect: no route to host가 발생했다면 방화벽 및 iptable을 재설정하자.
```bash
  sudo systemctl stop firewalld
  sudo systemctl stop firewall
  sudo systemctl stop ufw
  sudo systemctl stop kubelet.service
  sudo systemctl stop containerd.service
  sudo iptables --flush
  sudo iptables -tnat --flush
  sudo systemctl start kubelet.service
  sudo systemctl start containerd.service
  sudo systemctl start ufw
```